#include <regex.h>
#include <sys/types.h>
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <pthread.h>
#include <sys/stat.h>
#include <fcntl.h>

typedef struct file_stack{

    char* name;
    uint8_t type;   // 1 - file, 2 - directory
    struct file_stack* next;

}__attribute__((packed)) FILE_STACK;

typedef struct index_list{
    int32_t index;
    struct index_list* next;
}__attribute__((packed)) INDEX;


typedef struct file_info{

    char* filename;
    INDEX* indexes;    

}__attribute__((packed)) FILE_INFO;


FILE_STACK* top = NULL;

pthread_mutex_t operation_lock;

INDEX* add(INDEX* start, int32_t index){

    if(start == NULL){
        start = malloc(sizeof(INDEX));
        start->index = index;
        start->next  = NULL;
        return start;
    }

    INDEX* new_item = malloc(sizeof(INDEX));
    new_item->index = index;
    new_item->next  = NULL;

    return new_item;
}

/***
 * @brief
 * index returns to -1 if it is invalid.
 * Must take note of that when doing future work.
 * 
*/

INDEX* remove(INDEX* start, int32_t* index){

    if(start == NULL){
        *index = -1;
        return NULL;
    }

    INDEX* old_start = start;

    *index = old_start->index;

    /**
     * Just being used to practice sanitization of data.
    */
    old_start->next = NULL;
    old_start->index = -1;
    
    start = start->next;

    free(old_start);

    return start;

}

FILE_STACK* push(FILE_STACK* top, char* name, uint8_t type){
    pthread_mutex_lock(&operation_lock);
    if(top == NULL){
        FILE_STACK* node = malloc(sizeof(FILE_STACK));

        node->name = malloc(strlen(name) + 1);
        node->name[strlen(name)] = '\0';
        strcpy(node->name, name);
        node->type = type;

        node->next = NULL;    
        return node;
    }

    FILE_STACK* node = malloc(sizeof(FILE_STACK));

    node->name = malloc(strlen(name) + 1);
    node->name[strlen(name)] = '\0';
    strcpy(node->name, name);
    node->type = type;

    node->next = top;
    pthread_mutex_unlock(&operation_lock);
    return node;
}


FILE_STACK* pop(FILE_STACK* top){
    pthread_mutex_lock(&operation_lock);
    if(top == NULL){
        return NULL;
    }

    FILE_STACK* previous_top = top;

    top = top->next;

    memset(previous_top->name, 0, strlen(previous_top->name));

    free(previous_top->name);

    free(previous_top);

    pthread_mutex_unlock(&operation_lock);
    return top;

}


int analyze_file(char* filename){

    int fd = open(filename, O_RDONLY);

    if(fd < 0){
        perror("File could not be opened");
        return -1;
    }

    return 0;

}





void init(FILE_STACK* top){


    // pthread_t push_thread;
    // pthread_t pop_threads[5];
    // pthread_mutex_init(&operation_lock, NULL);






    return;

}


int main(int argc, char *argv[])
{

    if(argc < 2 ){
        perror("Error. Pleae use the following format: ./search <directory>");
        exit(EXIT_FAILURE);
    }

    

    

    top = push(top, argv[1], 2);


    pthread_mutex_destroy(&operation_lock);
    return 0;
}
