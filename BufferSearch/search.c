#include <regex.h>
#include <sys/types.h>
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <pthread.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>




typedef struct file_stack{

    char* name;
    uint8_t type;   // 1 - file, 2 - directory
    struct file_stack* next;

}__attribute__((packed)) FILE_STACK;

typedef struct index_list{
    int32_t index;
    struct index_list* next;
}__attribute__((packed)) INDEX;


typedef struct file_info{

    char* filename;
    INDEX* indexes;    

}__attribute__((packed)) FILE_INFO;

int logging_fd;


void init_loggingfile(){

    if(access("./log.byr", F_OK) == 0){
        logging_fd = open("./log.byr", O_WRONLY, 0666);
    }else{
        logging_fd = open("./log.byr", O_CREAT | O_WRONLY, 0666);
    }

    if(logging_fd < 0){
        perror("Could not open logging file");
        exit(0);
    }
}

enum Levels{
    WARNING = 0,
    ERROR   = 1,
    INFO    = 2
};

int write_log(char* log_info, uint8_t level){
    // if

    char MESSAGE[512];
    memset(MESSAGE, 0, 512);
    int wc;

    switch(level){
        case WARNING:
            
            sprintf(MESSAGE, "[WARNING]: %s\n", log_info);
            if((wc = write(logging_fd, MESSAGE, strlen(MESSAGE))) < 0){
                return -1;
            }
            break;
        case ERROR:
            sprintf(MESSAGE, "[ERROR]: %s\n", log_info);
            if((wc = write(logging_fd, MESSAGE, strlen(MESSAGE))) < 0){
                return -1;
            }
            break;
        case INFO:
            sprintf(MESSAGE, "[INFO]: %s\n", log_info);
            if((wc = write(logging_fd, MESSAGE, strlen(MESSAGE))) < 0){
                return -1;
            }
            break;
        default:
            sprintf(MESSAGE, "[ERROR]: %s\n", "Logging level not defined!");
            if((wc = write(logging_fd, MESSAGE, strlen(MESSAGE))) < 0){
                return -1;
            }
            break;
    }

    return 1;
}

FILE_STACK* top = NULL;

pthread_mutex_t operation_lock;

INDEX* add_index(INDEX* start, int32_t index){

    if(start == NULL){
        start = malloc(sizeof(INDEX));
        start->index = index;
        start->next  = NULL;
        return start;
    }

    INDEX* new_item = malloc(sizeof(INDEX));
    new_item->index = index;
    new_item->next  = NULL;

    return new_item;
}

/***
 * @brief
 * index returns to -1 if it is invalid.
 * Must take note of that when doing future work.
 * 
*/

INDEX* remove_index(INDEX* start, int32_t* index){

    if(start == NULL){
        *index = -1;
        return NULL;
    }

    INDEX* old_start = start;

    *index = old_start->index;

    /**
     * Just being used to practice sanitization of data.
    */
    old_start->next = NULL;
    old_start->index = -1;
    
    start = start->next;

    free(old_start);

    return start;

}

FILE_STACK* push(FILE_STACK* top, char* name, uint8_t type){
    pthread_mutex_lock(&operation_lock);
    if(top == NULL){
        FILE_STACK* node = malloc(sizeof(FILE_STACK));

        node->name = malloc(strlen(name) + 1);
        node->name[strlen(name)] = '\0';
        strcpy(node->name, name);
        node->type = type;

        node->next = NULL;    
        return node;
    }

    FILE_STACK* node = malloc(sizeof(FILE_STACK));

    node->name = malloc(strlen(name) + 1);
    node->name[strlen(name)] = '\0';
    strcpy(node->name, name);
    node->type = type;

    node->next = top;
    pthread_mutex_unlock(&operation_lock);
    return node;
}


FILE_STACK* pop(FILE_STACK* top){
    pthread_mutex_lock(&operation_lock);
    if(top == NULL){
        return NULL;
    }

    FILE_STACK* previous_top = top;

    top = top->next;

    memset(previous_top->name, 0, strlen(previous_top->name));

    free(previous_top->name);

    free(previous_top);

    pthread_mutex_unlock(&operation_lock);
    return top;

}

/**
 * @brief returns the start index if successful. 
 *        returns -1 if not sucessful.
 *        This index should be added to the base.
 * 
 *        For now I will only be search for functions and buffers with a fixed size
*/

int search_patterns(char* buffer){

    regex_t     function_pattern;
    char*       function_pattern_str = ".*(strcpy|sprintf|scanf|strcat|gets|memcpy)*.";

    // char*       function_pattern_str = "[a-z]{9}";
    int         rc = 0;

    int         index = 0;

    regmatch_t pmatch[15];
    size_t     nmatch = 15;

    

    char ERROR_MESSAGE[256];
    memset(ERROR_MESSAGE, 0, 256);

    if((rc == regcomp(&function_pattern, function_pattern_str, 0)) != 0){
        
        write_log("regcomp failure.", 1);
        regfree(&function_pattern);
        return -1;
    }

    if((rc == regexec(&function_pattern, buffer, nmatch, pmatch, 0)) != 0){

        write_log("regexec failure", 1);
        regfree(&function_pattern);
        return -1;
    }

    printf("HERE!");

    for(int i = 0; i < 15; i++){
        printf("%d -  %d\n", pmatch[i].rm_so, pmatch[i].rm_eo);
    }

    regfree(&function_pattern);
    return index;
}


int getfilesize(int file_descriptor){
    int fsize;
    fsize = lseek(file_descriptor, 0, SEEK_END);
    lseek(file_descriptor, 0, SEEK_SET);
    return fsize;
}

/**
 * @brief 
 * sprintf
 * 
 */


/***
 * @brief
 * Returns -1 when error. Must take that into account some time in the future.
*/
int analyze_file(char* filename){

    int analyze_fd = open(filename, O_RDONLY);

    if(analyze_fd < 0){
        perror("File could not be opened");
        return -1;
    }
    
    
    int file_size = getfilesize(analyze_fd);
    
    char file_buffer[file_size];

    memset(file_buffer, 0, file_size);

    
    
    read(analyze_fd, file_buffer, sizeof(file_buffer));
    

    search_patterns(file_buffer);

    char output_buffer[256];
    memset(output_buffer, 0, 256);

    sprintf(output_buffer, "filename %s analyzed", filename);
    write_log(output_buffer, 2);

    return 0;

}





void init(FILE_STACK* top){


    // pthread_t push_thread;
    // pthread_t pop_threads[5];
    // pthread_mutex_init(&operation_lock, NULL);






    return;

}


int main(int argc, char *argv[])
{

    // if(argc < 2 ){
    //     perror("Error. Pleae use the following format: ./search <directory>");
    //     exit(EXIT_FAILURE);
    // }

    

    

    // top = push(top, argv[1], 2);


    // pthread_mutex_destroy(&operation_lock);


    init_loggingfile();
    analyze_file("./search.c");
    write_log("error test ", 1);
    write_log("warning test", 0);
    write_log("info test ", 2);
    write_log("default test ", 3);

    return 0;
}
