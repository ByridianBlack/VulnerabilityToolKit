#include <regex.h>
#include <sys/types.h>
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <pthread.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>


#define KEEP_RUNNING 1


typedef struct file_stack{

    char* name;
    uint8_t type;   // 1 - file, 2 - directory
    struct file_stack* next;

}__attribute__((packed)) FILE_STACK;

typedef struct index_list{
    int32_t index;
    struct index_list* next;
}__attribute__((packed)) INDEX;


typedef struct file_info{

    char* filename;
    INDEX* indexes;    

}__attribute__((packed)) FILE_INFO;

int logging_fd;


void init_loggingfile(){

    if(access("./log.byr", F_OK) == 0){
        logging_fd = open("./log.byr", O_WRONLY, 0666);
    }else{
        logging_fd = open("./log.byr", O_CREAT | O_WRONLY, 0666);
    }

    if(logging_fd < 0){
        perror("Could not open logging file");
        exit(0);
    }
}

enum Levels{
    WARNING = 0,
    ERROR   = 1,
    INFO    = 2
};

int write_log(char* log_info, uint8_t level){
    // if

    char MESSAGE[512];
    memset(MESSAGE, 0, 512);
    int wc;

    switch(level){
        case WARNING:
            
            sprintf(MESSAGE, "[WARNING]: %s\n", log_info);
            if((wc = write(logging_fd, MESSAGE, strlen(MESSAGE))) < 0){
                return -1;
            }
            break;
        case ERROR:
            sprintf(MESSAGE, "[ERROR]: %s\n", log_info);
            if((wc = write(logging_fd, MESSAGE, strlen(MESSAGE))) < 0){
                return -1;
            }
            break;
        case INFO:
            sprintf(MESSAGE, "[INFO]: %s\n", log_info);
            if((wc = write(logging_fd, MESSAGE, strlen(MESSAGE))) < 0){
                return -1;
            }
            break;
        default:
            sprintf(MESSAGE, "[ERROR]: %s\n", "Logging level not defined!");
            if((wc = write(logging_fd, MESSAGE, strlen(MESSAGE))) < 0){
                return -1;
            }
            break;
    }

    return 1;
}

FILE_STACK* top = NULL;

pthread_mutex_t operation_lock;

INDEX* add_index(INDEX* start, int32_t index){

    if(start == NULL){
        start = malloc(sizeof(INDEX));
        start->index = index;
        start->next  = NULL;
        return start;
    }

    INDEX* new_item = malloc(sizeof(INDEX));
    new_item->index = index;
    new_item->next  = NULL;

    return new_item;
}

/***
 * @brief
 * index returns to -1 if it is invalid.
 * Must take note of that when doing future work.
 * 
*/

INDEX* remove_index(INDEX* start, int32_t* index){

    if(start == NULL){
        *index = -1;
        return NULL;
    }

    INDEX* old_start = start;

    *index = old_start->index;

    /**
     * Just being used to practice sanitization of data.
    */
    old_start->next = NULL;
    old_start->index = -1;
    
    start = start->next;

    free(old_start);

    return start;

}

FILE_STACK* push(FILE_STACK* top, char* name, uint8_t type){
    pthread_mutex_lock(&operation_lock);
    if(top == NULL){
        FILE_STACK* node = malloc(sizeof(FILE_STACK));

        node->name = malloc(strlen(name) + 1);
        node->name[strlen(name)] = '\0';
        strcpy(node->name, name);
        node->type = type;

        node->next = NULL;    
        return node;
    }

    FILE_STACK* node = malloc(sizeof(FILE_STACK));

    node->name = malloc(strlen(name) + 1);
    node->name[strlen(name)] = '\0';
    strcpy(node->name, name);
    node->type = type;

    node->next = top;
    pthread_mutex_unlock(&operation_lock);
    return node;
}


FILE_STACK* pop(FILE_STACK* top){
    pthread_mutex_lock(&operation_lock);
    if(top == NULL){
        return NULL;
    }

    FILE_STACK* previous_top = top;

    top = top->next;

    memset(previous_top->name, 0, strlen(previous_top->name));

    free(previous_top->name);

    free(previous_top);

    pthread_mutex_unlock(&operation_lock);
    return top;

}

/**
 * @brief returns the start index if successful. 
 *        returns -1 if not sucessful.
 *        This index should be added to the base.
 * 
 *        For now I will only be search for functions and buffers with a fixed size
*/
int search_patterns (char* buffer){

    regex_t     function_pattern;

    char*       function_pattern_str = "sprintf|strcpy|strcat|gets|scanf";

    int         rc = 0;

    int         index = 0;

    regmatch_t pmatch[15];
    size_t     nmatch = 15;

    

    char ERROR_MESSAGE[512];
    memset(ERROR_MESSAGE, 0, 512);

    if((rc = regcomp(&function_pattern, function_pattern_str, REG_EXTENDED)) != 0){
        
        write_log("regcomp failure.", 1);
        regfree(&function_pattern);
        return -1;
    }

    
    int match_end   = 0;

    while(KEEP_RUNNING){
        rc = regexec(&function_pattern, buffer, nmatch, pmatch, 0);

        if(rc){
            // printf("HERE!@");
            write_log("regexec failure or no more matches", 1);
            regfree(&function_pattern);
            return 0;
        }

        for(int i = 0; i < 15; i++){
            if(pmatch[i].rm_eo == -1){
                break;
            }
            // match_start = pmatch[i].rm_so;
            match_end   = pmatch[i].rm_eo;
            sprintf(ERROR_MESSAGE, "With the whole expression, a matched substring \"%.*s\" is found at position %d to %d.", pmatch[i].rm_eo - pmatch[i].rm_so, &buffer[pmatch[i].rm_so], pmatch[i].rm_so, pmatch[i].rm_eo - 1);
            
            write_log(ERROR_MESSAGE, 2);
            memset(ERROR_MESSAGE, 0, 512);
            buffer = buffer + match_end;
        }
        
    }

    regfree(&function_pattern);
    return index;
}


/**
 * @brief Similar to the previous search. This one just adds support for line numbers. Line numbers as opposed to position
 * Is much faster.
 * 
*/
int search_patterns_lines(char* filename, char* buffer){

    char placeholder[1024];

    regex_t     function_pattern;

    char*       function_pattern_str = "sprintf|strcpy|strcat|gets|scanf";

    int         rc = 0;


    regmatch_t pmatch[15];
    size_t     nmatch = 15;

    char LOG_MESSAGE[1024];
    

    memset(placeholder, 0, strlen(placeholder));

    memset(LOG_MESSAGE, 0, 1024);

    if((rc = regcomp(&function_pattern, function_pattern_str, REG_EXTENDED)) != 0){
        
        write_log("regcomp failure.", 1);
        regfree(&function_pattern);
        return -1;
    }


    int line_count = 1;

    int match_end = 0;
    // size_t size_of_buffer = strlen(buffer);

    for(size_t i = 0; i < strlen(buffer); i++){
        if(buffer[i] == '\n'){
            
            int size_of_line = strlen(placeholder);


            /**
             * Nothing of value probably? Will see as time goes on.
            */
            if(size_of_line < 4){
                memset(placeholder, 0, size_of_line);
                line_count+=1;
                continue;
            }
            
            match_end = 0;
            char* ptr_handle = placeholder;
            while(KEEP_RUNNING){
                if((rc = regcomp(&function_pattern, function_pattern_str, REG_EXTENDED)) != 0){
        
                    write_log("regcomp failure.", 1);
                    regfree(&function_pattern);
                    return -1;
                }
                rc = regexec(&function_pattern, placeholder, nmatch, pmatch, 0);

                if(rc){
                    write_log("regexec failure or no more matches", 1);
                    regfree(&function_pattern);
                    break;
                }
                for(int i = 0; i < 15; i++){
                    if(pmatch[i].rm_eo == -1){
                        break;
                    }
                    match_end = pmatch[i].rm_so;

                    sprintf(LOG_MESSAGE, "Filename: %s contains With the whole expression, a matched substring \"%.*s\" is found at position %d to %d on line %d", filename, pmatch[i].rm_eo - pmatch[i].rm_so, &placeholder[pmatch[i].rm_so], pmatch[i].rm_so, pmatch[i].rm_eo - 1, line_count);
                    write_log(LOG_MESSAGE, 1);
                    memset(LOG_MESSAGE, 0, 1024);
                    ptr_handle = ptr_handle + match_end;
                }
            }
            


            line_count+=1;

            // printf("Line number: %d \n\n%s", line_count, placeholder);
            memset(placeholder, 0, size_of_line);
            
        }else{
            strncat(placeholder, &buffer[i], 1);
        }
    }


    return 0;
}


int getfilesize(int file_descriptor){
    int fsize;
    fsize = lseek(file_descriptor, 0, SEEK_END);
    lseek(file_descriptor, 0, SEEK_SET);
    return fsize;
}

/**
 * @brief 
 * sprintf
 * 
 */


/***
 * @brief
 * Returns -1 when error. Must take that into account some time in the future.
*/
int analyze_file(char* filename){

    int analyze_fd = open(filename, O_RDONLY);

    if(analyze_fd < 0){
        perror("File could not be opened");
        return -1;
    }
    
    
    int file_size = getfilesize(analyze_fd);
    
    char file_buffer[file_size+1];
    

    memset(file_buffer, 0, file_size+1);

    
    
    read(analyze_fd, file_buffer, sizeof(file_buffer));
    

    // search_patterns(file_buffer);
    search_patterns_lines(filename, file_buffer);

    char output_buffer[256];
    memset(output_buffer, 0, 256);

    sprintf(output_buffer, "filename %s analyzed", filename);
    write_log(output_buffer, 2);

    return 0;

}





void init(FILE_STACK* top){


    // pthread_t push_thread;
    // pthread_t pop_threads[5];
    // pthread_mutex_init(&operation_lock, NULL);






    return;

}


int main(int argc, char *argv[])
{

    // if(argc < 2 ){
    //     perror("Error. Pleae use the following format: ./search <directory>");
    //     exit(EXIT_FAILURE);
    // }

    

    

    // top = push(top, argv[1], 2);


    // pthread_mutex_destroy(&operation_lock);


    init_loggingfile();
    analyze_file("./search.c");

    return 0;
}
