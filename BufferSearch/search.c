#include <regex.h>
#include <sys/types.h>
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <pthread.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>




typedef struct file_stack{

    char* name;
    uint8_t type;   // 1 - file, 2 - directory
    struct file_stack* next;

}__attribute__((packed)) FILE_STACK;

typedef struct index_list{
    int32_t index;
    struct index_list* next;
}__attribute__((packed)) INDEX;


typedef struct file_info{

    char* filename;
    INDEX* indexes;    

}__attribute__((packed)) FILE_INFO;

int logging_fd;


void init_loggingfile(){

    if(access("./log.byr", F_OK) == 0){
        logging_fd = open("./log.byr", O_WRONLY, 0666);
    }else{
        logging_fd = open("./log.byr", O_CREAT | O_WRONLY, 0666);
    }

    if(logging_fd < 0){
        perror("Could not open logging file");
        exit(0);
    }
}

int write_log(char* log_info, uint8_t level){

}

FILE_STACK* top = NULL;

pthread_mutex_t operation_lock;

INDEX* add_index(INDEX* start, int32_t index){

    if(start == NULL){
        start = malloc(sizeof(INDEX));
        start->index = index;
        start->next  = NULL;
        return start;
    }

    INDEX* new_item = malloc(sizeof(INDEX));
    new_item->index = index;
    new_item->next  = NULL;

    return new_item;
}

/***
 * @brief
 * index returns to -1 if it is invalid.
 * Must take note of that when doing future work.
 * 
*/

INDEX* remove_index(INDEX* start, int32_t* index){

    if(start == NULL){
        *index = -1;
        return NULL;
    }

    INDEX* old_start = start;

    *index = old_start->index;

    /**
     * Just being used to practice sanitization of data.
    */
    old_start->next = NULL;
    old_start->index = -1;
    
    start = start->next;

    free(old_start);

    return start;

}

FILE_STACK* push(FILE_STACK* top, char* name, uint8_t type){
    pthread_mutex_lock(&operation_lock);
    if(top == NULL){
        FILE_STACK* node = malloc(sizeof(FILE_STACK));

        node->name = malloc(strlen(name) + 1);
        node->name[strlen(name)] = '\0';
        strcpy(node->name, name);
        node->type = type;

        node->next = NULL;    
        return node;
    }

    FILE_STACK* node = malloc(sizeof(FILE_STACK));

    node->name = malloc(strlen(name) + 1);
    node->name[strlen(name)] = '\0';
    strcpy(node->name, name);
    node->type = type;

    node->next = top;
    pthread_mutex_unlock(&operation_lock);
    return node;
}


FILE_STACK* pop(FILE_STACK* top){
    pthread_mutex_lock(&operation_lock);
    if(top == NULL){
        return NULL;
    }

    FILE_STACK* previous_top = top;

    top = top->next;

    memset(previous_top->name, 0, strlen(previous_top->name));

    free(previous_top->name);

    free(previous_top);

    pthread_mutex_unlock(&operation_lock);
    return top;

}

/**
 * @brief returns the start index if successful. 
 *        returns -1 if not sucessful.
 *        This index should be added to the base.
 * 
 *        For now I will only be search for functions and buffers with a fixed size
*/

int search_patterns(char* buffer){

    
    regex_t     function_pattern;
    char*       function_pattern_str = ".*(strcpy|sprintf|scanf|strcat|gets|memcpy)*.";
    int         rc;

    int index;

    if((rc == regcomp(&function_pattern, function_pattern_str, REG_EXTENDED)) != 0){
        
        // write(logging_fd, "[ERROR]");
        // printf("recomp failed");
        return -1;
    }
    
    // if(())
    

    return index;
}

/***
 * @brief
 * Returns -1 when error. Must take that into account some time in the future.
*/
int analyze_file(char* filename){

    int analyze_fd = open(filename, O_RDONLY);

    if(analyze_fd < 0){
        perror("File could not be opened");
        return -1;
    }

    char file_buffer[4096];
    memset(file_buffer, 0, 4096);

    int base = 0;
    int n = 0;
    while((n = read(analyze_fd, file_buffer, sizeof(file_buffer))) != 0){
        write(STDOUT_FILENO, file_buffer, sizeof(file_buffer));
        memset(file_buffer, 0, sizeof(file_buffer));

        base+=n;
    }

    return 0;

}





void init(FILE_STACK* top){


    // pthread_t push_thread;
    // pthread_t pop_threads[5];
    // pthread_mutex_init(&operation_lock, NULL);






    return;

}


int main(int argc, char *argv[])
{

    // if(argc < 2 ){
    //     perror("Error. Pleae use the following format: ./search <directory>");
    //     exit(EXIT_FAILURE);
    // }

    

    

    // top = push(top, argv[1], 2);


    // pthread_mutex_destroy(&operation_lock);


    init_loggingfile();
    analyze_file("./search.c");

    return 0;
}
